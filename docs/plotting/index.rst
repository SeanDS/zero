.. include:: /defs.txt

Plotting
========

|Zero| relies on the powerful `Matplotlib <https://matplotlib.org/>`__ plotting library. In all
cases, the plots produced by |Zero| can be further modified in ways supported by Matplotlib.

Plotting in analysis scripts
----------------------------

In scripts, plots are generated by the call to the :ref:`solution <solution/index:Solutions>`'s
:meth:`~.Solution.plot_responses` or :meth:`~.Solution.plot_noise` methods. These support many
display options, as listed below. The return value from these methods is the
:class:`~matplotlib.figure.Figure`, which can be
:ref:`further modified <plotting/index:Further modifying plots generated by |Zero|>`.

After calling either :meth:`~.Solution.plot_responses` or :meth:`~.Solution.plot_noise`, you can
show the generated plots with :meth:`~.Solution.show`. This method is called separately to allow
you to show a number of plots simultaneously.

Responses
~~~~~~~~~

.. automethod:: zero.solution.Solution.plot_responses
   :noindex:

Noise spectral densities
~~~~~~~~~~~~~~~~~~~~~~~~

.. automethod:: zero.solution.Solution.plot_noise
   :noindex:

Further modifying plots generated by |Zero|
-------------------------------------------

If you wish to apply further styling to a plot generated by |Zero|, you can do so using `Matplotlib
<https://matplotlib.org/>`__ method calls on the :attr:`~.MatplotlibPlotter.figure` property of the
:class:`.MatplotlibPlotter` object. An example is shown below.

.. plot::
    :include-source:

    import numpy as np
    from zero import Circuit
    from zero.analysis import AcSignalAnalysis

    # (Unimportant) circuit definition.
    frequencies = np.logspace(-2, 5, 1000)
    circuit = Circuit()
    circuit.add_library_opamp(model="LT1124", node1="n1", node2="n3", node3="n4")
    circuit.add_capacitor(value="10u", node1="gnd", node2="n2")
    circuit.add_resistor(value="2k", node1="n2", node2="n3")
    circuit.add_resistor(value="100k", node1="n3", node2="n4")
    circuit.add_capacitor(value="1.5n", node1="n3", node2="n4")
    analysis = AcSignalAnalysis(circuit=circuit)
    solution = analysis.calculate(frequencies=frequencies, input_type="voltage", node="n1")

    # Create a response plot.
    plotter = solution.plot_responses(sink="n4")

    # Get the underlying Matplotlib figure handle.
    handle = plotter.figure

    # Make a Matplotlib call, in this case to add a horizontal line.
    ax1 = handle.axes[0]  # Get the upper subplot.
    ax1.axhline(34, np.min(frequencies), np.max(frequencies), color="black", linestyle="--", alpha=0.5)

    # Display on screen.
    plotter.show()

Further details about the available axis methods can be found in the `Matplotlib axes API
documentation <https://matplotlib.org/api/axes_api.html>`__.

You can also set the :class:`.Solution`'s :attr:`~.Solution.response_plotter` and
:attr:`~.Solution.noise_plotter` attributes to custom :class:`.BaseGroupPlotter` implementations to
provide full control over plotting capabilities.

Plotting from the command line
------------------------------

The LISO compatibility command line interface provides some options for controlling the display
of plots and for saving copies to the file system. See
:ref:`LISO tools in the CLI section <cli/liso:LISO tools>` for more information.
